* 异步			：	异步是关于现在和将来的时间间隙，通过时间队列和环境监听将一件事情分为现在和将来两个部分
* 同步操作	：	操作一个一个执行


### Promise

用同步一样的方式书写异步代码
```
let p = new Promise(function(resolve, reject){
	// 异步代码
	// resolve ->  成功
	// reject -> 失败
	$.ajax({
		url: url,
		dataType: "json",
		success(data){
			resolve();
		},
		error(err){
			reject();
		}
	})
})

p.then(function(data){}, function(res){})

Promise.all([p1, p2]).then(function(dataArr){
	let [res1, res2] = dataArr;
}, function(res){
})
```

实际上 jquery 的 ajax 方法返回的就是一个 promise 对象
```
Promise.all([
	$.ajax({url: "array.txt", dataType: "json"}),
	$.ajax({url: "json.txt", dataType: "json"})
]).then(function(results){
	let [res1, res2] = results;
}, function(error){
})
```

##### race

和 Promise.all 不同，all 是要加入 Promise 数组中的所有对象都执行完了才算成功，有一个失败就算失败了；
Promise.race  是其中一个 Promise 对象执行成功就算成功了，其它的就不执行。

### generator

普通函数执行的时候是从开始一直执行到函数返回
generator 也是一个函数，不过比较特殊的是执行过程中可以暂停，让程序执行其它的东西
声明 generator 函数的方式, 不能简写成箭头函数
```
function *foo(){
	alert('a');

	yield;

	alert('b');
}

let generatorObj = foo();
generatorObj.next(); // 执行到第一个 yield, 没有 yield 就执行到函数结尾
```
##### yield

+ 传参
+ 有返回值

返回值示例：
```
function *foo(){
	alert('a');

	yield 12;  //  返回值

	alert('b');
	return 5;
}

let obj = foo();
let ret1 = obj.next(); // ret1 = {value: 12, done: false}
let ret2 = obj.next(); // ret2 = {value: 5, done: true}
```

传参示例：
```
function *foo(a){
	alert(a);

	let c = yield;

	alert(c);
}

let obj = foo(9);
obj.next();   // a = 9
obj.next(90); // c = 90
```
使用场景：当执行了一部分时需要等待其它操作结束

npm i yield-runner-blue

### async & await

async await 取代了 generator
场景：三个操作a1-a3, a2需要使用 a1 的返回结果
使用 promise 是不行的，没有顺序控制。generator 可以做到，但是 async 和 await 更加优雅。
```
async function show(){
	let promise1 = $.ajax(url: "data1.json", dataType: "json");
	let promise2 = $.ajax(url: "data2.json", dataType: "json");
	let promise3 = $.ajax(url: "data3.json", dataType: "json");
	let data1 = await promise1;
	if(data1){
		let data2 = await promise2;
	}else{
		let data3 = await promise3;
	}
}
```

> https://www.bilibili.com/video/av50680998/?p=138
