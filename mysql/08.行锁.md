### 行锁

行锁就是针对数据库表中行记录的锁，两个事务并发更新同一行数据时会应发阻塞，必须等前一个事务完成以后后面的事务才能执行更新。

mysql 的行锁是各个引擎各自实现的，并非所有引擎都支持，mysql默存储引擎Myisam就不支行锁。
不支持行锁意味着并发控制只能使用表锁，这种情况下同一张表任何时候只能执行一个更新语句。
innodb是支持行锁的，所以innodb的并发控制机制比MyIsam的粒度更细，性能也就更好。

#### 两阶段锁协议

在innodb事务中，行锁是在需要的时候加上（比如执行update语句），直到事务结束（commit或者rollback）时才释放。
* 开启事务一直使用select语句不会加行锁，直到使用update，delete等更新时才加行锁。
由于两阶段锁协议的的影响，当事务中需要锁多个行时，为了尽可能减少锁等待的时间，需要把能造成行锁冲突的操作放到后面，避免影响并发性能。

#### 死锁和死锁检测

当并发系统中不同线程之间出现循环锁资源相互依赖，就会导致线程都进入无线等待状态----死锁

例如：

| 线程A | 线程B |
-----------------
| begin| begin|
|update t set k=k+1 where id = 1| update t set m = m+1 where id = 2|
|update b set m = m + 1 where id = 2| update set k=k+1 where id = 1|

对于线程A，在第一阶段获取了id=1的行锁，线程B获取了id=2的行锁
在第二阶段线程A需要对id=2的行进行操作，但是需要等待线程B释放改行锁，
但此时线程B需要对id=1的行进行操作，但是需要等待线程A释放行锁，
这样，由于两个线程都需要在事务结束才会释放对应的行锁，所以两个线程都在等待对方释放锁，这样就形成了死锁。

处理死锁有两种策略：
1. 设置超时等待， ***innodb_lock_wait_timeout***
2. 发起死锁检测，将参数：***innodb_deadlock_detect***设置为on，发现死锁后主动回滚其中一个事务，其余事务继续执行。

对于第一种策略，innodb默认超时时间是50s，对于一般的服务时间过长，但设置时间多短又可造成误伤，所以一般情况下使用第二种策略，innodb引擎默认就是开启死锁检测的。

为了避免死锁，一般情况下在不同的事务中尽量按相同的顺序执行语句。
