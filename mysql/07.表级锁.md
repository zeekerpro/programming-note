### 表级锁

msyql表级锁有两种：表锁，元数据锁

#### 1.表锁

加锁：
- lock tables ... read/write
释放锁：
- unlock 
- 客户端连接断开自动释放锁

local tables 除了限制别的线程读写，还会影响自己的操作
例如：
lock tables t1 read, t2 write
表示：当前线程拥有的所有权限就是读 t1, 读写t2。 不能读和写其它所有表，其它线程写t1，读写t2都会阻塞。

#### 2. 元数据锁MDL

MDL不需要显式使用，在访问一个表的时候会自动被加上保证读写的正确性。
当对一个表增删改查操作时加MDL读锁，当一个线程更改表结构时加MDL写锁。
读锁之间不互斥，所以多个线程可对同一张表增删改查。
写锁和读、写锁都是互斥的，所以当一个线程在修改一个表结构时，其余线程的操作都会被阻塞。

因为MDL在事务提交的时候才会被释放，所以在做表结构更改的时候，一定要小心锁住线上查询和更新。
比如 
1. session1 线程开启事务，执行select语句，申请读锁
3. session2 执行ddl语句，修改表结构，申请写锁，和session1的读锁互斥，被阻塞
4. session3 执行select，申请读锁，和session3写锁互斥，阻塞
这种情况下当客户端有重试机制，如果 session 是个长事务，一直不提交，那么很容易导致连接数据库的线程爆满，把数据库卡死。
所以应该尽量避免长事务。

为了避免写锁会后面的读锁互斥造成的大量线程爆满，AliSql、MariaDB两个mysql分支都支持了ddl wait/nowaid 机制： 如果session2在指定时间内（或者一次尝试后）没有获取写锁，那么就会放弃，之后再手动重试。
```
alter table T NOWAIT N column...
alter table T WAIT N add column ...
```

