索引的出现就是为了提高查询效率

每张表就是好几棵B+树，有几个索引就有几棵B+树。

如果是主键索引，那么树节点的key值就是主键，树节点的value值是记录整行数据。搜索的时候只需要搜索主键这一棵B+树。在innodb中主键索引也叫***聚簇索引***。

如果是非主键索引，那么树节点的key值就是非主键，树节点的vlue值是记录的主键。搜索的时候先搜索非主键索引树，的到主键值后再搜索主键树，这个过程叫做***回表***，也就是非主键索引需要多扫描一次索引树。非主键索引也叫***二级索引***。
#### 索引维护

对于自增的主键索引，新增记录的时候在B+树append一个节点就可以了
但是如果还有非主键索引，为了维护索引的顺序，有可能要在原来的B+树插入一个节点，逻辑上就需要挪动后面的数据，如果当前的数据页已经满了，根据B+树的算法需要申请一个新的数据页，然后挪动部分数据过去，这个过程叫做页分裂，会影响到性能和数据页的利用率。
当然如果是删除记录，有可能会页合并。

#### 重建索引

- 重建非主键索引
```
alter table T drop index k;
alter table T add index(k);
```
删除索引，然后新建索引

- 重建主键索引
```
alter table T drop primary key;
alter table T add primary key(id);
```
因为非主键索引树的节点value值是主键值，如果采用这种方式重建索引，会影响到非主键索引的索引值，所以不推荐使用。
可以使用
```
alter table T engine=innoDB;
```
重建主键索引

#### 覆盖索引

在一个表上如果有两颗索引树：二级索引k，和主键索引id
执行 
```
select * from T where k between 3 and 5;
```
的时候，检索过程为：

- 在k的索引树上找到k=3的节点，然后回表获取对应的记录
- 对k=3后面的节点回表获取记录
- 一直到k=6的节点，不满足条件循环结束

执行 
```
select id from T where k between 3 and 5;
```
因为k索引树的节点value就是id值，所以不需要回表，表现为索引k已经覆盖了查询需求，这就是***覆盖索引***。
使用覆盖索引不需要回表，可以减少树的检索次数，提高查询性能。

#### 联合索引

一般情况下使用联合索引的目的就是通过覆盖索引提高查询效率。比如一个用户信息表，id是主键，用户还有身份证号码和姓名，当通过身份证号码获取用户姓名是一个高频请求的时候，就可以把身份证号码和姓名建立一个联合索引，不通过回表从而提高了效率。联合索引树的节点格式 如下：
```
(ID_card, name) => id
```
该联合索引树节点的key值是 (身份证，姓名),value值是主键id

##### 建立联合索引的原则

1. 最左前缀原则
对于上面的例子，如果稍微改一改，如果根据身份证获取家庭住址，该如何检索：
当然新建一个（身份证，地址）的联合索引查询效率会很不错，但是当一个表建立索引过多的时候维护成本就会大大增加，由于索引树的都是顺序的，也就是说根据索引的最左前缀可以用来定位记录。
所以当需要根据身份证获取家庭地址的时候，可以先使用（身份证，姓名）索引树，先检索身份证，然后回表获取地址信息。
根据最左前缀原则，我们在建立联合索引的时候，哪个键作为左前缀可以减少维护索引，那么就以那个键作为前缀，如上例中，如果以姓名为前缀建立联合索引（姓名，身份证）对于需要通过身份证检索地址的需求就需要重新建立（身份证，地址）的索引，这显然会对维护索引带来很高的成本。

2. 空间节省原则
如果一个表column：name， age
既有基于age，name联合查询的需求，也有根据age，name的各自的检索需求，
因为name字段比age大，所以推荐建立索引为（name，age) +（age）
否则建立(age,name) + (name) 占用空间会很大

####  索引下推
 
对于建立了(name, age)的表，如果执行 query：
```
select * from t where name like "张%" and age=10 and ismale=1;
```
回通过***索引下推***优化，减少回表的次数，流程如下：
1. 通过联合索引 name 符合条件的节点
2. 在联合索引树节点上下推判断 age 是否符合条件
3. 如果满足条件再回表继续检索判断记录中的 ismale 是否符合条件

对于 mysql5.6以前的版本，不会通过索引下推优化检索，而是对于索引树上每个 name 满足条件的节点都会回表判断 age 和 ismale。
