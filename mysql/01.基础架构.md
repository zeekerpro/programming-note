## 一、server 层

- Server 层包括连接器、查询缓存、分析器、优化器、执行器等
- 涵盖了大多数核心服务功能和所有的内置函数
- 所有的跨存储引擎的功能，比如存储过程，触发器，视图

### 1. 连接器

负责和客户端连接处理

	* tcp 连接握手：网络层的连接建立

	* 验证身份：验证用户名和密码

	* 权限设置：读取权限表查询权限

注意：对一个已经存在的连接修改用户权限只有在重新登录后才会生效，因为权限设置是在建立连接的时候做的

#### 连接状态

可以使用 show processlist; 命令查询当前数据的连接状态
* 如果当前的连接没有动作就处于空闲状态 sleep，反之为 query, 如果太长时间没有动静，连接器就会断开连接，该时间由*wait_timeout*参数控制
* 如果连接成功后客户端持续请求，则使用一个连接处理，这个连接就是长连接，每次执行很少的查询就断开连接，下次查询重新建立则为短连接。 因为建立连接的过程一般比较复杂，所以应该尽量使用长连接。
* 因为执行过程中临时使用的内存是管理在连接对象中的，这些资源在断开连接时释放，如果长连接累积会使得内存占用过大，mysql 会被系统强行杀掉。解决方法：
	+ 定期断开长连接，使用一段时间或者程序执行过一个占用内存大的查询后断开连接，然后重新建立连接
	+ mysql5.7以上可以通过执行 *mysql_reset_connection* 初始化连接资源，会将连接恢复至刚创建完的状态

### 2. 查询缓存

mysql 拿到一个查询请求时会先去查询缓存中检查之前有没有执行过着条语句，如果有则直接取出，如果没有就继续执行执行阶段，然后将查询结果存入缓存中。

但是在表更新时关联的查询缓存就会被清空，所以对于更新频繁的表禁用查询缓存会提高效率。

将参数 *query_cache_type* 设置成 DEMAND 默认禁用查询缓存，然后对于需要缓存的 query 使用*SQL_CACHE*显式指定
```
select SQL_CACHE * from T where ID=1;
```

**mysql5.8没有查询缓存的功能**

### 3. 分析器 

做查询语句的此法分析和语法分析

### 4. 优化器

对查询语句做优化，提高执行效率

### 5. 执行器

- 判断用户对查询的表有没有权限
- 有权限则打开表继续执行，执行器根据表的引擎定义，使用引擎接口查询结果，和存储引擎层交互


## 二、存储引擎层

- 负责数据的存储和提取
- 插件式架构模式，支持 innoDB、MyISAM, memory 等存储引擎
	crete table 建表的时候不指定存储引擎则默认为 innodb，可以使用 engine=memory 使用内存引擎创建表

1. 查看存储引擎：
```
show engines;
```

2. 查看表的存储引擎
```
show create table tablename;
```

3. 修改表的存储引擎
```
alter table table_name engine=innodb;
```

