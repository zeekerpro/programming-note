### 接口中的成员修饰符是固定的
接口没有构造函数，java是单继承的，构造函数只有类有，如果接口中有构造函数当继承了了多个接口的时候无法确定调用次序

* 成员常量： public static final
	+ public: 对外提供访问，否则该成员没有意义。
	+ static: java是单继承的，子类访问父类属性和调用父类方法时会使用super，然而super是无法访问到实现接口中的属性和方法。
		如果接口成员属性是非静态的，那么就意味着其实现类对象可以直接使用接口中的成员变量
		那么当两个接口中成员的变量名相同时，如果一个类同时实现这两个接口，就无法区分到底使用的是哪个变量了。
		换句话说，实现类接口中的属性是非静态的那么该属性就像实现类自己的属性一样。
		接口在子类对象中不像父类有一个单独的父类空间，而是隶属于子类对象的，当两个接口的非静态属性同名的时候就会在同一个对象中出现两个同名的变量。
		而当使用 static 修饰属性的时候，即便两个接口中存在同名变量，那这两个变量也是存在于实现类静态区的不同位置，使用向上转型或者接口名称一样可以区分访问。(当没有同名的时候，使用对象名就可以访问了)
	+ final: 因为接口属性是static的，所以所有实现类都共享一个属性，如果不加上final，那么这个静态属性会被修改，而影响其它实现类的使用。
* 成员函数： public abstract
	public: 对外提供访问
	abstract: 接口是可以多继承的，多继承的根源在于方法体。有方法体了就不能多继承了。
		如果有方法体，子类就可以不实现--一旦两个接口中方法同名，子类如果不实现，将造成调用混乱。
		所以必须让子类实现而运行子类的实现代码，既然子类一定实现又何必在接口中再实现一遍, 
		为了保证子类一定要实现，就必须将方法作为抽象方法。

#### 接口和接口之间是继承关系，并且可以多继承
```java
interface I1 {}
interface I2 {}
interface I3 extends I1, I2 {}
```
多继承问题的根源在于方法体和非静态属性，而接口没有方法体和非静态属性，所以可以多继承。
假设类可以多继承，譬如C继承了两个类 A，B， A和B中都有方法foo，并且签名相同，实现不同。
子类继承父类方法后是可以不覆盖的,如果C中没有覆盖foo方法，C类对象在调用foo的时候就会犯迷糊，到底调用的是A中的foo还是B中的foo。
而如果A，B只要有一个是接口，那么C就必须实现foo方法，这样在调用的时候就能确定调用的方法是C的foo方法。

### 抽象类继承接口可以不实现接口方法

注意：
接口中的成员因为修饰符是固定的，所以推荐写法是在写接口的时候不用显式加上修饰符。
但是在实现接口的方法的时候一定要加上 public， 否则实现类会默认为包权限，而子类覆盖方法的时候可见性不能缩小。

### 接口新特性
##### 静态方法
javaSE8中允许给接口增加静态方法，理论上是合法的，然而违背了接口作为抽象规范的初衷。

##### 默认方法
javaSE8 中可以为接口方法提供默认实现，但是必须用 default 修饰符标记
```java
public interface Comparable<T>{
	default int compareTo(T other){
		return 0;
	}
}
```
接口演化：
	以 Collection 接口为例，这个接口作为java的一部分已经有很多年了，假设之前提供了一个实现类
	public class Bag implements Collection 
	到了 java8中，需要为这两个类添加一个新方法 stream ;
	这时候可以使用默认方法，而不需要在接口子类中重新实现一遍了，并且接口子类可以调用新加的默认方法。
默认方法的冲突：
	如果接口的默认方法和超类的方法签名是一样的，那么超类优先。
	如果两个接口的默认方法签名是一样的，则实现类中必须覆盖这个方法。

默认方法的优点：
	不需要将所有子类重新实现一遍。
	在子类实现的时候，如果只关注了接口中的几个方法，可以将所有方法申明为默认方法，而仅仅实现关注的方法即可。
