## 装饰设计模式 简介
字符流缓冲区两个主要类就是使用的装饰模式

继承的方式也能实现装饰模式的功能呢，二者有什么区别

装饰着模式设计思维演变：
设有 class A --> 现欲将 A 增强 F --> 使用面向对象的思维 --> class SubA extends A 添加增强属性(或使用接口，或自定义属性)
再有 class B --> 也要将 B 增强 F --> .... --> class SubB extends B ...
...
使用继承的弊端就出来了 ： 将会导致继承体系越来越臃肿，不够灵活，且不易扩展，试想如果想要 A，B 同事具有 F1 ,F2 那就得多重继承,这种继承关系将会越来越复杂而低效

重新思考这个问题，既然都是想增强 F 功能，就将F功能抽象出来，需要增强那个对象就将那个对象和功能关联起来
```
class WrapperF {
	...

	public WrapperF(A a){
		...
	}
	
	public WrapperF(B b){
		...
	}
}
```

为了使体系更加灵活和语义化，使用 A ，B 的父类来构造装饰器,假设 A 和 B 的父类是 S
```
class WrapperS extends S {
	...
	public WrapperS(S s){
	}
}	
```

根据泛型技术，这样就可以兼容 A 和 B, 这是一种向上抽象的做法，实际开发中需要考虑到泛型的限制而做好继承体系。

装饰模式的特点或者要求
* 装饰着和被装饰者需要继承同一个父类或接口，武林至尊也是武林人士，不过是武林人士的加强版

