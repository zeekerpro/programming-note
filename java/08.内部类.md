### 内部类

#### 内部类能够访问到外部类成员是因为内部类持有一个外部类对象引用。

```java
class Test{
	int num = 9;

	class Inner {
		int num = 90;
		public void show(){
			int num = 99;
			System.out.println(num); 		// 99
			System.out.println(this.num);		// 90
			System.out.println(Inner.this.num);	// 90
			System.out.println(Test.this.num); 	// 9
		}
	}

	public static void main(String[] args) {
		Test.Inner ti = new Test().new Inner();
		ti.show();

		Inner t2 = new Inner(); // 非静态内部类在实例化的时候需要传入一个外部类对象的引用，静态方法没有外部类引用，无法传递给内部类对象，所以这一句编译不通过(在非静态方法中可以这样使用,因为非静态方法被对象调用的时候有外部类对象引用)
	}

}
```

#### 如果内部类是静态的，就不会持有外部类对象引用，所以就只能访问外部类静态成员属性。

#### 如果内部类中定义了一静态成员，则该内部类也必须是静态的。
	一个类的静态属性在类加载的时候就要被加载，并开辟空间存放静态属性，所以并不依赖于对象。
	内部类中有静态成员，就说明该静态成员需要被先加载并分配内存空间。
	然而该内部类的静态成员需要先加载的必要条件是该内部类要被先加载。
	内部类要被先加载，该内部类就应该作为外部类的静态成员。
	该问题的核心就是类加载的时候就会开辟内存存放静态成员，普通成员不是随类加载而生成的。


### 局部内部类
局部内部类同样持有外部类的引用，可以访问外部类成员。
局部内部类只能访问final修饰的局部变量，就是说局部内部类只能访问局部的常量。
> https://segmentfault.com/a/1190000002735907
> https://segmentfault.com/q/1010000010732463

### 匿名内部类
前提：
	内部类必须继承或者实现一个类或者接口.
匿名内部类其实就是一个匿名的子类对象。
由于构造器的名字必须与类名相同，而匿名类没有类名，所以匿名类不能有构造函数，
当继承类的时候会将需要的参数传递给父类构造器，而实现接口的时候更不能有构造器了。

```java
interface Nest{
	void show();
}

class Test {
	public void show(){
		new Nest(){ 			// 注意这里调用了构造函数，有小括号
			public void show(){  	//注意这里需要加上 public，覆盖方法的时候可见性不能缩小。
				System.out.println("xxx");
			}
		}.show();
	}
}
```
常见使用场景：
* 方法参数是接口类型的时候，使用匿名内部类对象作为实际参数传递。但是为了保证阅读性，匿名内部类中实现的方法最好不要太多(<=3 个)。
